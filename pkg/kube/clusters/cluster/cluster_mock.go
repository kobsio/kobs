// Code generated by mockery v2.12.3. DO NOT EDIT.

package cluster

import (
	context "context"

	controllerRuntimeClient "sigs.k8s.io/controller-runtime/pkg/client"


	dashboardv1 "github.com/kobsio/kobs/pkg/kube/apis/dashboard/v1"

	http "net/http"

	mock "github.com/stretchr/testify/mock"

	multipart "mime/multipart"

	runtime "k8s.io/apimachinery/pkg/runtime"

	teamv1 "github.com/kobsio/kobs/pkg/kube/apis/team/v1"

	userv1 "github.com/kobsio/kobs/pkg/kube/apis/user/v1"

	v1 "github.com/kobsio/kobs/pkg/kube/apis/application/v1"

	websocket "github.com/gorilla/websocket"
)

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

// CopyFileFromPod provides a mock function with given fields: ctx, w, namespace, name, container, srcPath
func (_m *MockClient) CopyFileFromPod(ctx context.Context, w http.ResponseWriter, namespace string, name string, container string, srcPath string) error {
	ret := _m.Called(ctx, w, namespace, name, container, srcPath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, http.ResponseWriter, string, string, string, string) error); ok {
		r0 = rf(ctx, w, namespace, name, container, srcPath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CopyFileToPod provides a mock function with given fields: ctx, namespace, name, container, srcFile, destPath
func (_m *MockClient) CopyFileToPod(ctx context.Context, namespace string, name string, container string, srcFile multipart.File, destPath string) error {
	ret := _m.Called(ctx, namespace, name, container, srcFile, destPath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, multipart.File, string) error); ok {
		r0 = rf(ctx, namespace, name, container, srcFile, destPath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateResource provides a mock function with given fields: ctx, namespace, name, path, resource, subResource, body
func (_m *MockClient) CreateResource(ctx context.Context, namespace string, name string, path string, resource string, subResource string, body []byte) error {
	ret := _m.Called(ctx, namespace, name, path, resource, subResource, body)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, []byte) error); ok {
		r0 = rf(ctx, namespace, name, path, resource, subResource, body)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteResource provides a mock function with given fields: ctx, namespace, name, path, resource, body
func (_m *MockClient) DeleteResource(ctx context.Context, namespace string, name string, path string, resource string, body []byte) error {
	ret := _m.Called(ctx, namespace, name, path, resource, body)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []byte) error); ok {
		r0 = rf(ctx, namespace, name, path, resource, body)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetApplication provides a mock function with given fields: ctx, namespace, name
func (_m *MockClient) GetApplication(ctx context.Context, namespace string, name string) (*v1.ApplicationSpec, error) {
	ret := _m.Called(ctx, namespace, name)

	var r0 *v1.ApplicationSpec
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *v1.ApplicationSpec); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ApplicationSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetApplications provides a mock function with given fields: ctx, namespace
func (_m *MockClient) GetApplications(ctx context.Context, namespace string) ([]v1.ApplicationSpec, error) {
	ret := _m.Called(ctx, namespace)

	var r0 []v1.ApplicationSpec
	if rf, ok := ret.Get(0).(func(context.Context, string) []v1.ApplicationSpec); ok {
		r0 = rf(ctx, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v1.ApplicationSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCRDs provides a mock function with given fields:
func (_m *MockClient) GetCRDs() []CRD {
	ret := _m.Called()

	var r0 []CRD
	if rf, ok := ret.Get(0).(func() []CRD); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]CRD)
		}
	}

	return r0
}

// GetClient provides a mock function with given fields: ctx, schema
func (_m *MockClient) GetClient(ctx context.Context, schema *runtime.Scheme) (controllerRuntimeClient.Client, error) {
	ret := _m.Called(ctx, schema)

	var r0 controllerRuntimeClient.Client
	if rf, ok := ret.Get(0).(func(context.Context, *runtime.Scheme) controllerRuntimeClient.Client); ok {
		r0 = rf(ctx, schema)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(controllerRuntimeClient.Client)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *runtime.Scheme) error); ok {
		r1 = rf(ctx, schema)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDashboard provides a mock function with given fields: ctx, namespace, name
func (_m *MockClient) GetDashboard(ctx context.Context, namespace string, name string) (*dashboardv1.DashboardSpec, error) {
	ret := _m.Called(ctx, namespace, name)

	var r0 *dashboardv1.DashboardSpec
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *dashboardv1.DashboardSpec); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dashboardv1.DashboardSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDashboards provides a mock function with given fields: ctx, namespace
func (_m *MockClient) GetDashboards(ctx context.Context, namespace string) ([]dashboardv1.DashboardSpec, error) {
	ret := _m.Called(ctx, namespace)

	var r0 []dashboardv1.DashboardSpec
	if rf, ok := ret.Get(0).(func(context.Context, string) []dashboardv1.DashboardSpec); ok {
		r0 = rf(ctx, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dashboardv1.DashboardSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLogs provides a mock function with given fields: ctx, namespace, name, container, regex, since, tail, previous
func (_m *MockClient) GetLogs(ctx context.Context, namespace string, name string, container string, regex string, since int64, tail int64, previous bool) (string, error) {
	ret := _m.Called(ctx, namespace, name, container, regex, since, tail, previous)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, int64, int64, bool) string); ok {
		r0 = rf(ctx, namespace, name, container, regex, since, tail, previous)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, int64, int64, bool) error); ok {
		r1 = rf(ctx, namespace, name, container, regex, since, tail, previous)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetName provides a mock function with given fields:
func (_m *MockClient) GetName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetNamespaces provides a mock function with given fields: ctx
func (_m *MockClient) GetNamespaces(ctx context.Context) ([]string, error) {
	ret := _m.Called(ctx)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResources provides a mock function with given fields: ctx, namespace, name, path, resource, paramName, param
func (_m *MockClient) GetResources(ctx context.Context, namespace string, name string, path string, resource string, paramName string, param string) ([]byte, error) {
	ret := _m.Called(ctx, namespace, name, path, resource, paramName, param)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string) []byte); ok {
		r0 = rf(ctx, namespace, name, path, resource, paramName, param)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, string, string) error); ok {
		r1 = rf(ctx, namespace, name, path, resource, paramName, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTeam provides a mock function with given fields: ctx, namespace, name
func (_m *MockClient) GetTeam(ctx context.Context, namespace string, name string) (*teamv1.TeamSpec, error) {
	ret := _m.Called(ctx, namespace, name)

	var r0 *teamv1.TeamSpec
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *teamv1.TeamSpec); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*teamv1.TeamSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTeams provides a mock function with given fields: ctx, namespace
func (_m *MockClient) GetTeams(ctx context.Context, namespace string) ([]teamv1.TeamSpec, error) {
	ret := _m.Called(ctx, namespace)

	var r0 []teamv1.TeamSpec
	if rf, ok := ret.Get(0).(func(context.Context, string) []teamv1.TeamSpec); ok {
		r0 = rf(ctx, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]teamv1.TeamSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTerminal provides a mock function with given fields: ctx, conn, namespace, name, container, shell
func (_m *MockClient) GetTerminal(ctx context.Context, conn *websocket.Conn, namespace string, name string, container string, shell string) error {
	ret := _m.Called(ctx, conn, namespace, name, container, shell)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *websocket.Conn, string, string, string, string) error); ok {
		r0 = rf(ctx, conn, namespace, name, container, shell)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetUser provides a mock function with given fields: ctx, namespace, name
func (_m *MockClient) GetUser(ctx context.Context, namespace string, name string) (*userv1.UserSpec, error) {
	ret := _m.Called(ctx, namespace, name)

	var r0 *userv1.UserSpec
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *userv1.UserSpec); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*userv1.UserSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsers provides a mock function with given fields: ctx, namespace
func (_m *MockClient) GetUsers(ctx context.Context, namespace string) ([]userv1.UserSpec, error) {
	ret := _m.Called(ctx, namespace)

	var r0 []userv1.UserSpec
	if rf, ok := ret.Get(0).(func(context.Context, string) []userv1.UserSpec); ok {
		r0 = rf(ctx, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]userv1.UserSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchResource provides a mock function with given fields: ctx, namespace, name, path, resource, body
func (_m *MockClient) PatchResource(ctx context.Context, namespace string, name string, path string, resource string, body []byte) error {
	ret := _m.Called(ctx, namespace, name, path, resource, body)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []byte) error); ok {
		r0 = rf(ctx, namespace, name, path, resource, body)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StreamLogs provides a mock function with given fields: ctx, conn, namespace, name, container, since, tail, follow
func (_m *MockClient) StreamLogs(ctx context.Context, conn *websocket.Conn, namespace string, name string, container string, since int64, tail int64, follow bool) error {
	ret := _m.Called(ctx, conn, namespace, name, container, since, tail, follow)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *websocket.Conn, string, string, string, int64, int64, bool) error); ok {
		r0 = rf(ctx, conn, namespace, name, container, since, tail, follow)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// loadCRDs provides a mock function with given fields:
func (_m *MockClient) loadCRDs() {
	_m.Called()
}

type NewMockClientT interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockClient(t NewMockClientT) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
