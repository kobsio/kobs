// Code generated by mockery v2.12.1. DO NOT EDIT.

package satellite

import (
	context "context"
	http "net/http"

	dashboardv1 "github.com/kobsio/kobs/pkg/kube/apis/dashboard/v1"

	mock "github.com/stretchr/testify/mock"

	plugin "github.com/kobsio/kobs/pkg/satellite/plugins/plugin"

	teamv1 "github.com/kobsio/kobs/pkg/kube/apis/team/v1"

	testing "testing"

	userv1 "github.com/kobsio/kobs/pkg/kube/apis/user/v1"

	v1 "github.com/kobsio/kobs/pkg/kube/apis/application/v1"
)

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

// GetApplications provides a mock function with given fields: ctx
func (_m *MockClient) GetApplications(ctx context.Context) ([]v1.ApplicationSpec, error) {
	ret := _m.Called(ctx)

	var r0 []v1.ApplicationSpec
	if rf, ok := ret.Get(0).(func(context.Context) []v1.ApplicationSpec); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v1.ApplicationSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusters provides a mock function with given fields: ctx
func (_m *MockClient) GetClusters(ctx context.Context) ([]string, error) {
	ret := _m.Called(ctx)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDashboards provides a mock function with given fields: ctx
func (_m *MockClient) GetDashboards(ctx context.Context) ([]dashboardv1.DashboardSpec, error) {
	ret := _m.Called(ctx)

	var r0 []dashboardv1.DashboardSpec
	if rf, ok := ret.Get(0).(func(context.Context) []dashboardv1.DashboardSpec); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dashboardv1.DashboardSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetName provides a mock function with given fields:
func (_m *MockClient) GetName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetPlugins provides a mock function with given fields: ctx
func (_m *MockClient) GetPlugins(ctx context.Context) ([]plugin.Instance, error) {
	ret := _m.Called(ctx)

	var r0 []plugin.Instance
	if rf, ok := ret.Get(0).(func(context.Context) []plugin.Instance); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]plugin.Instance)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTeams provides a mock function with given fields: ctx
func (_m *MockClient) GetTeams(ctx context.Context) ([]teamv1.TeamSpec, error) {
	ret := _m.Called(ctx)

	var r0 []teamv1.TeamSpec
	if rf, ok := ret.Get(0).(func(context.Context) []teamv1.TeamSpec); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]teamv1.TeamSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsers provides a mock function with given fields: ctx
func (_m *MockClient) GetUsers(ctx context.Context) ([]userv1.UserSpec, error) {
	ret := _m.Called(ctx)

	var r0 []userv1.UserSpec
	if rf, ok := ret.Get(0).(func(context.Context) []userv1.UserSpec); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]userv1.UserSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Proxy provides a mock function with given fields: w, r
func (_m *MockClient) Proxy(w http.ResponseWriter, r *http.Request) {
	_m.Called(w, r)
}

// NewMockClient creates a new instance of MockClient. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockClient(t testing.TB) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
